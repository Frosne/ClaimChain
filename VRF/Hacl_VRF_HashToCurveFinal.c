/* This file was auto-generated by KreMLin! */

#include "Hacl_VRF_HashToCurveFinal.h"

void Hacl_VRF_HashToCurveFinal_toU8(uint8_t *out, uint32_t input)
{
  void *s = Spec_Lib_IntSeq_uint_to_bytes_le(Spec_Lib_IntTypes_U32, (void *)input);
  uint8_t s0 = Spec_Lib_IntSeq_index((krml_checked_int_t)4, s, (krml_checked_int_t)0);
  uint8_t s1 = Spec_Lib_IntSeq_index((krml_checked_int_t)4, s, (krml_checked_int_t)1);
  uint8_t s2 = Spec_Lib_IntSeq_index((krml_checked_int_t)4, s, (krml_checked_int_t)2);
  uint8_t s3 = Spec_Lib_IntSeq_index((krml_checked_int_t)4, s, (krml_checked_int_t)3);
  out[0U] = s0;
  out[1U] = s1;
  out[2U] = s2;
  out[3U] = s3;
}

bool Hacl_VRF_HashToCurveFinal_isNotPointAtInfinity(uint64_t *p)
{
  uint64_t x0 = p[0U];
  uint64_t x0u = x0;
  uint64_t x1u = x0;
  uint64_t x2u = x0;
  uint64_t x3u = x0;
  uint64_t x4u = x0;
  uint64_t y0 = p[5U];
  uint64_t y0u = y0;
  uint64_t y1 = p[6U];
  uint64_t y1u = y1;
  uint64_t y2 = p[7U];
  uint64_t y2u = y2;
  uint64_t y3 = p[8U];
  uint64_t y3u = y3;
  uint64_t y4 = p[9U];
  uint64_t y4u = y4;
  uint64_t z0 = p[10U];
  uint64_t z0u = z0;
  uint64_t z1 = p[11U];
  uint64_t z1u = z1;
  uint64_t z2 = p[12U];
  uint64_t z2u = z2;
  uint64_t z3 = p[13U];
  uint64_t z3u = z3;
  uint64_t z4 = p[15U];
  uint64_t z4u = z4;
  uint64_t t0 = p[15U];
  uint64_t t0u = t0;
  uint64_t t1 = p[5U];
  uint64_t t1u = t1;
  uint64_t t2 = p[6U];
  uint64_t t2u = t2;
  uint64_t t3 = p[7U];
  uint64_t t3u = t3;
  uint64_t t4 = p[8U];
  return
    x0u
    == (uint64_t)0U
    && x1u == (uint64_t)0U
    && x2u == (uint64_t)0U
    && x3u == (uint64_t)0U
    && x4u == (uint64_t)0U
    && y0u == (uint64_t)1U
    && y1u == (uint64_t)0U
    && y2u == (uint64_t)0U
    && y3u == (uint64_t)0U
    && y4u == (uint64_t)0U
    && z0u == (uint64_t)0U
    && z1u == (uint64_t)0U
    && z2u == (uint64_t)0U
    && z3u == (uint64_t)0U
    && z4u == (uint64_t)0U
    && t0u == (uint64_t)1U
    && t1u == (uint64_t)0U
    && t2u == (uint64_t)0U
    && t3u == (uint64_t)0U
    && t4 == (uint64_t)0U;
}

void Hacl_VRF_HashToCurveFinal_pointMult8(uint64_t *out, uint64_t *p)
{
  uint64_t buf[40U] = { 0U };
  uint64_t *a = buf;
  uint64_t *b = buf + (uint32_t)20U;
  Hacl_VRF_Lib_point_double(a, p);
  Hacl_VRF_Lib_point_double(b, a);
  Hacl_VRF_Lib_point_double(out, b);
}

bool
Hacl_VRF_HashToCurveFinal__helper_ECVRF_hash_to_curve(
  Prims_nat len,
  uint64_t *pointBuffer,
  uint8_t *output,
  uint32_t clen,
  uint32_t counter,
  uint64_t *pointTemporary
)
{
  uint32_t inputLength = clen - (uint32_t)96U;
  uint32_t startBufferForCounter = inputLength + (uint32_t)32U;
  uint32_t lengthBufferToInputHash = inputLength + (uint32_t)36U;
  uint8_t *bufferForInputHash = output;
  uint8_t *bufferForComputedHash = output + lengthBufferToInputHash;
  uint8_t *placeForCounter = output + startBufferForCounter;
  Hacl_VRF_HashToCurveFinal_toU8(placeForCounter, counter);
  Hacl_VRF_Lib_hash(bufferForComputedHash, lengthBufferToInputHash, bufferForInputHash);
  bool successful = Hacl_VRF_Lib_decompress(pointTemporary, bufferForComputedHash);
  bool isInfinity = Hacl_VRF_HashToCurveFinal_isNotPointAtInfinity(pointTemporary);
  if (successful && isInfinity)
  {
    Hacl_VRF_HashToCurveFinal_pointMult8(pointBuffer, pointTemporary);
    return true;
  }
  else
  {
    uint32_t maxCounter = (uint32_t)0xffffU;
    uint32_t counterComparable = counter;
    if (maxCounter <= counterComparable)
      return false;
    else
    {
      uint32_t counterComparable1 = counter;
      uint32_t counterUpd = counterComparable1 + (uint32_t)1U;
      return
        Hacl_VRF_HashToCurveFinal__helper_ECVRF_hash_to_curve(len,
          pointBuffer,
          output,
          clen,
          counterUpd,
          pointTemporary);
    }
  }
}

bool
Hacl_VRF_HashToCurveFinal__ECVRF_hash_to_curve(
  Prims_nat len,
  uint64_t *pointBuffer,
  uint64_t *publicKey,
  uint32_t clen,
  uint8_t *input
)
{
  uint32_t sizeToHashBuffer = clen + (uint32_t)96U;
  uint32_t startOfInput = (uint32_t)32U;
  KRML_CHECK_SIZE((uint8_t)0U, sizeToHashBuffer);
  uint8_t buf[sizeToHashBuffer];
  memset(buf, 0U, sizeToHashBuffer * sizeof buf[0U]);
  uint8_t *inputBuffer = buf + startOfInput;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = input[i];
    inputBuffer[i] = src_i;
  }
  uint8_t *compressedPublicKey = buf;
  Hacl_VRF_Lib_compress(compressedPublicKey, publicKey);
  uint64_t buf1[20U] = { 0U };
  bool
  r =
    Hacl_VRF_HashToCurveFinal__helper_ECVRF_hash_to_curve(FStar_UInt32_v(sizeToHashBuffer),
      pointBuffer,
      buf,
      sizeToHashBuffer,
      (uint32_t)0U,
      buf1);
  bool r0 = r;
  return r0;
}

