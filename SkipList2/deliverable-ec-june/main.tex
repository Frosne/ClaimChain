\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\title{Deliverable EC June 2017}
\author{Ann Weine}

\begin{document}
\maketitle

\section{Introduction}
The next part of the paper will be dedicated to F* and our implementation of skiplist in the language. \\
We will explain why this particular language was chosen for our project and why this data structure was chosen as the most suitable in terms of performance and usability. 

\section{FStar as a language for formalisation}
F* (FStar) is a functional programming language aimed at program verification: \hyperlink{https://fstar-lang.org/}{FStar main page}. The language includes dependent types, refinement types in the type system. It allows to write the efficient and functional correct code. \\
Nevertheless, there exist several languages that have the same approach: \hyperlink{https://coq.inria.fr/}{The Coq Proof Assistant}, \hyperlink{https://ocaml.org/}{OCaml}. 
The language was chosen due to the several reasons. One of them is that the written code could be easily extracted to C. It means that the code in C will have the same proofs of correctness/side-channel resistance as the source code. 
The second reason is the possibility to easily prove some specific security properties about the written code. \\
\\ The language has already several successful applications. It is widely used for protocol verification. One of the most well-known applications is verified reference implementation of the TLS protocol: \hyperlink{https://mitls.org/}{miTLS}. 

\section{SkipList}
The next part will be dedicated to the explanation of skiplist as a data structure, the underlying concepts and proofs of efficiency. 
\subsection{Definition}
Skiplist is a data structure that is used to store data. It is built based on usual linked list and combines the ideas of linked list and some specific features to increase the performance of several operations in skiplist. \\
Our implementation of skiplist consists of two data structures. One of them in used to store the data, while the second one serves as the indexes storage. \\ The main draw of the data structure is that there is no need to go through to whole data structure to find an element, as it is done over traditional lists. The complexity of linked list is O(n), while the average complexities of search/insert/delete algorithms for skiplist is $log(n)$ where n is the number of elements stored in skiplist. \\
We will show the way it's implemented as a comparison with a linked list. Each element of a linked list has a connection to the next element. At the same time, skiplist has a several connections to the next elements. It gives an opportunity to decrease the number of elements to go though by the search routine. The number of the elements to be connected is chosen randomly, but there exists at least one connection to the next element. It means that the skiplist could be equally used as a linked list. The worst performance in terms of the speed will the same as the performance of linked list.\\ Of course, the memory consumption is slightly more than for the linked list. For each element in general there is a $log(n) * sizeof(index)$ memory overhead, where n is a number of elements in skiplist and index is a memory needed to store the reference to the next element. \\
The data structure is very often used in the frameworks when it's important to provide a good level of performance, for example a database management systems: \hyperlink{https://en.wikipedia.org/wiki/MemSQL} {MemSQL}.
\subsection{API}
Our implementation supports the following API: \begin{itemize}
\item Inserting of a new element
\item Searching for an existing element
\item Search for an element by index
\item Removing an existing element (this and the next one is not used in ClaimChain, it was implemented for consistency and re-use of data structure). 
\item Removing an existing element found by index
\item Splitting a skiplist into 2 skiplists
\end{itemize}
\subsection{Insert}
The insertion is implemented as a routine to insert a new claim into the Claimchain. \\
Due to the reason that the skiplist is an ordered structure, the whole process of adding a new element into the skiplist could be divided into two subroutines, searching a place for the new element to be inserted and the insert itself. \\ The algorithm for the place finding will be discussed in the next subsection. 
In terms of the insert of element, the most interesting part is to re-build the connections to the previous/next parts of the list and to adapt the previous list. \\
\subsection{Search}
The search procedure is implemented as a routine in order to find a claim in the existing claimchain. \\
As a small reminder of the definition: each element has the index list (the list where the indexes to the next elements are stored). A claim could be got by the index. The indexes are constructed such way that all the elements that are references by the indexes satisfy a predicate (for example, all the next coming elements could be strictly more than the current element). The index list is ordered, the first element references by the index list will be the biggest, the last element has a reference to the next coming element. \\
In order to find an element, ones starts with a first element. If the element is not the one one is looking for, one goes to the index list. For all the indexes, one checks whether the element is bigger than the element one is looking for. If 'yes', the next element will be checked, otherwise, one will have the element referenced by the indexes as a new starting point. The routine will be continued until the element is found. \\
For the simplicity of use, there were implemented several functions to easily get the next/previous element after the search. At the same time, a slightly changed search algorithm is used in a insertion and splitting routine. \\ 
\subsection{Split}
The split procedure is implemented as a routine in order to split a claimchain into two splitted skiplists. It could be useful if one wants to reason about the particular part of the skiplist or in case of the need to take/change/use the particular part of skiplist (in case of part of chain being compromised). \\
The split over the skiplist is implemented as a routine, that divides the sequences into two and according to several rules change the index list for the splitted parts.
\\ The split could be done either by the index of the elements or by the concrete element. The last means that the search of the element is done first. It is followed by the split in the first mode. 
\subsection{Remove}
The remove procedure is not used in claimchain due to the append-only policy, it was implemented just for the consistency of the data structure. 
\\ The remove procedure is very closely implemented as a split procedure, with a small difference that the first element of the one of sequences will be removed and the skiplists will be connected again. 
\subsection{Future development}
As a future part of the work it will be implemented a skiplist with a hashes for all the elements. \\ The hash will consist of the hash of the data and the hash of the indexes. It will give us some security guarantees of non-repudiation of the data. n auditor will be able to any moment of time to check that there was no data injection in between.\\ At the same time, it will give us an additional guarantee that the indexes to the other elements were not also changed. \\ It will lead to a small change of memory consumption for the data structure. The additional memory will be equal to the size of hash of element and need to be mupliply by the number of all the elements. It will slightly change the addition procedure and the procedures that change either the value of the skiplist or the indexes: for each change it will be needed to regenerate a hash. 
\end{document}
