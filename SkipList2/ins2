module SkipList2.Insertion2

open SkipList2.Statement
open SkipList2.Properties
open FStar.Option
open FStar.Seq
open FStar.List.Tot

module Sl = SkipList2.Statement
module List = FStar.List.Tot
module Seq = FStar.Seq


type searchResult (a:eqtype) (f:cmp a) (sl: skipList a f) (value: a) (counter_global_previous: nat) = 
| NotFound: 
    counter_global : nat 
        {
        counter_global > counter_global_previous /\
        counter_global < (Sl.length sl -1) /\ 
        (f (Seq.index (getValues sl) (counter_global)) value)
        }
    -> searchResult a f sl value counter_global_previous
| Found:  
    place: nat
        { 
            (place+1) < Sl.length sl /\
            (f value (Seq.index (getValues sl) (place+1))) /\
            (f (Seq.index (getValues sl) place) value)
        }
     -> searchResult a f sl value counter_global_previous


(*)

assume val change_indexes: #a : eqtype -> #f : cmp a -> sl:skipList a f {Sl.length sl > 0} -> value: a -> 
                    place: nat {place < Sl.length sl /\ 
                    f (Seq.index (getValues sl) place) value /\
                    (place = 0 \/ f(Seq.index (getValues sl) (place -1)) value = false)
                    } -> 
                    Tot(r: seq (non_empty_list nat) {Seq.length r = Sl.length sl + 1 })

val sorted_seq_concat_wrapper : #a: eqtype -> f: cmp a ->pivot : a -> s1: seq a 
            {Seq.sorted f s1 /\ (forall y. (Seq.mem y s1 ==> f y pivot))} ->  
            s2: seq a {Seq.sorted f s2 /\ (forall y. (Seq.mem y s2 ==> f pivot y))}  ->
          Tot(s3: seq a{Seq.sorted f s3 /\ Seq.length s3 = Seq.length s1 + Seq.length s2 + 1}) 

let sorted_seq_concat_wrapper #a f pivot s1 s2 = 
        let s3 = (Seq.append s1 (cons pivot s2)) in 
        FStar.Seq.Properties.sorted_concat_lemma #a f s1 pivot s2; 
        s3      

val change_values: #a: eqtype -> f: cmp a -> sl: skipList a f -> value : a -> 
         place: nat{ 
                place < (Sl.length sl) /\
                f value (Seq.index (getValues sl) place) /\
                (place =0 \/  f (Seq.index (getValues sl) (place-1)) value)} ->
        Tot(s3: seq a{Seq.sorted f s3 /\ 
        Seq.length s3 = Sl.length sl+ 1 
    }) 

let change_values #a f sl value place = 
    let s1 = lemma_ch1_wrapper #a f sl value place in 
    let s2 = lemma_ch2_wrapper #a f sl value place in 
    sorted_seq_concat_wrapper #a f value s1 s2  *)
(*)


*) 


val last_element_indexed: #a: eqtype -> #f: cmp a -> sl: skipList a f {Sl.length sl > 1} -> 
                            counter_global: nat{counter_global < (Sl.length sl -1)} -> 
        Tot nat 
let last_element_indexed #a #f sl counter_global = 
    let ind = getIndex sl counter_global in 
    let len = (List.length ind) -1  in 
    List.index ind len

val last_element_values: #a: eqtype -> #f: cmp a -> sl: skipList a f {Sl.length sl > 1} -> Tot(a)
let last_element_values #a #f sl = 
    let values = Sl.getValues sl in 
    let length = Seq.length values -1 in 
    Seq.index values length 

assume val lemma_last_element_biggest: #a : eqtype -> #f: cmp(a)  ->  sl: skipList a f{Sl.length sl > 1} -> value: a
-> Lemma (ensures (f value (last_element_values  #a #f sl)))    

assume val lemma_index_3 : #a: eqtype -> #f: cmp a -> sl:skipList a f {Sl.length sl > 1} -> 
                    counter_global:nat{counter_global < (Sl.length sl -1)} -> 
                    Lemma(ensures(last_element_indexed #a #f sl counter_global = counter_global +1))



private val searchPlaceIndex: #a: eqtype -> #f: cmp a -> sl : skipList a f{Sl.length sl> 1} -> value: a-> 
                        counter_global: nat{counter_global < (Sl.length sl -1) /\ 
                            (f (Seq.index (getValues sl) counter_global ) value) } -> 
                        counter_local : nat{ counter_local <List.length
                                (getIndex sl counter_global)} ->
                        Tot(searchResult a f sl value counter_global)(decreases(List.length (getIndex sl counter_global) - counter_local))

let rec searchPlaceIndex #a #f sl value counter_global counter_local  = 
    let values = getValues sl in 
    let index = lemma_index_1_2_wrapper #a #f sl counter_global counter_local in 
    lemma_last_element_biggest #a #f sl value;
    if  (f value (Seq.index values index)) then 
        (
            if (f (Seq.index values (index-1)) value ) then 
                Found (index-1)
            else if (counter_local  = (List.length (getIndex sl counter_global) -1)) then
                let result = lemma_index_3 #a #f sl    counter_global in 
                Found counter_global    
            else 
                let counter_local = counter_local + 1 in  searchPlaceIndex #a #f sl value counter_global counter_local 
        )        
    else NotFound index    (* if inf -> not exist*)

val searchPlaceSequence: #a:eqtype-> #f: cmp(a) ->sl: skipList a f{Sl.length sl> 1}-> value : a -> 
            counter_global:nat{counter_global < (Sl.length sl -1) /\ 
            (f (Seq.index (getValues sl) counter_global) value) }  -> 
            Tot(place: nat{ 
                place < (Sl.length sl -1) /\
                (f value (Seq.index (getValues sl) (place+1))) /\
                (f (Seq.index (getValues sl) place) value)
                })
            (decreases (Sl.length sl - counter_global))

let rec searchPlaceSequence #a #f sl value counter_global =
    let result = searchPlaceIndex #a #f sl value counter_global 0 in 
        match result with     
            | Found index ->  index 
            | NotFound counter_global_new ->  
                searchPlaceSequence #a #f sl value (counter_global_new)

val searchPlace : #a : eqtype -> #f: cmp(a)  ->  sl: skipList a f{Sl.length sl > 1} -> value: a-> 
                Tot(place: nat{ 
                (place < (Sl.length sl -1 )) /\
                (
                    (place = 0 /\ f value (Seq.index (getValues sl) 0))  \/ 
                        (
                            (f value (Seq.index (getValues sl) (place+1)))
                             /\ (f (Seq.index (getValues sl) place) value)
                        )
                )
            })

let searchPlace #a #f  sl value =
    let counter_global = 0 in 
    if (f value (Seq.index (getValues sl) counter_global)) then 
        counter_global
    else if (Sl.length sl = 1) then (lemma_last_element_biggest #a #f sl value; counter_global)
    else
        searchPlaceSequence #a #f sl value counter_global
(*)
val addition: #a: eqtype -> #f: cmp a -> 
        sl: skipList a f {Sl.length sl > 0}-> 
        value : a -> Tot (r: skipList a f{Sl.length r = Sl.length sl + 1})

let addition #a #f sl value  = 
    let place = searchPlace #a #f sl value in 
    let values = change_values #a f sl value place in 
    let indexes = change_indexes #a #f sl value place in 
    Mk values indexes
